### This file does bsts MC simulations using data generated by Ox ###

library(plyr)
library(glmnet)
library(bsts)
library(BoomSpikeSlab)
	
	cRep=1000
	prob <- 0.15
	#sink(paste("C:/Users/Fiona.Sloof/Desktop/Thesis/Feb01/Results/BSTS_", experiment, ".txt", sep = ''), split=TRUE)
	
	

for (u in 1:10)
{
	
	case = u
#settings for state space component -- can add to this
	loclintrend = TRUE 

	setwd(paste("/Users/f/projects/masters-thesis/data/simulated data/Case", case, sep = ''))
	set.seed(1)

#print out simulation design
	print(paste("This is BSTS case", case))
	print("In this simulation...")
	print(paste("There are", cRep, "repetitions"))
	if(loclintrend)
		{
		print("There is a local linear trend component")
		}

	print(paste("The probability of inclusion threshold is set to", prob))

#begin timer
	ptm <- proc.time()

#simulation design - open first spreadsheet to create results matrix
	data_rep1 = read.csv("repnum1.csv")
#delete x variables we don't want to include
	delete1 = names(data_rep1) %in% c("X","Constant")
#put data into matrix form
	data_rep1a = data_rep1[!delete1]
	nregressors = ncol(data_rep1a)

#create dataframe with true parameters
	truepar = read.csv(paste("/Users/f/projects/masters-thesis/data/simulated data/Case", case, "/TrueParValues.csv", sep = ''),stringsAsFactors = FALSE)
	delete1 = names(data_rep1) %in% c("X", "y")
	truepardata = data_rep1[!delete1]
	regressors = paste("x", colnames(truepardata), sep = '')
	truepar.df = data.frame(regressors,truepar)
	delete2 = names(truepar.df) %in% c("X")
	truepar.df = truepar.df[!delete2]
	truepar.df <- truepar.df[!(truepar.df$regressors == "xConstant"),]

#First iteration for set-up of simulation
	x=model.matrix(y~.,data_rep1a)[,-1]
	y=data_rep1$y

#state specification
	if (loclintrend)
	{
	ss <- AddLocalLinearTrend(state.specification=NULL, y)
	}
	
#Model for first rep	
	bsts.model <- bsts(y~x, state.specification = ss, niter = 100, ping=0, seed=1)	
	
#Matrix of coefficients + other summary statistics	
	summ<-SummarizeSpikeSlabCoefficients(bsts.model$coefficients)
	
#Column five is the inclusion probability across all niters
	repnum1.incprob <- summ[,5]
#Column one is the mean coefficient estimate
	repnum1.meancoef <- summ[,1]	

#create dataframe with inclusion probabilities and mean coefficient estimates
	df.results <- data.frame(repnum1.incprob, repnum1.meancoef)
	#create new column for indicators
	zerovector <- matrix(0, nrow = nrow(df.results), ncol =1)
	#add new indicator column to dataframe
	df.results$indicator <- zerovector
	
#Set indicator variable	
	for (l in 1:nrow(df.results$indicator))
	{
	if (df.results$repnum1.incprob[l] > prob)
	{
		df.results$indicator[l] <- 1
		
	}
	}

#Name column with inclusion probabilites for particular rep 1
	names(df.results)[1] <- paste("incprob1")
	
#create column with row names corresponding to regressors - this seems backwards but the rownames are qualified as a variable so save them as a variable 
df.results$regressors <- rownames(df.results)


#merge results and true parameter dataframes. At this point we have a results df for this particular rep which includes the parameter estimates, indicator, true paramter
	df.results <- merge(df.results, truepar.df)

#Delete Intercept row since is not in True Parameters dataframe
	df.results <-df.results[!(df.results$regressors == "(Intercept)"),]

#create variable for MSE
	df.results$mse <- round((df.results$TrueParameterValues - df.results$repnum1.meancoef)^2, digits = 4)

#create variable for unconditional mean squared errors
	df.results$cmse <- matrix(0, nrow = nrow(df.results), ncol =1)

for(k in 1:nrow(df.results))
	{
	if(df.results$indicator[k] == 1)
		{
		df.results$cmse[k] = round(df.results$mse[k], digits = 4)
		}
	else
		{
		df.results$cmse[k] = 0
		}
	}

#create variable for unconditional mean squared errors
	df.results$umse <- matrix(0, nrow = nrow(df.results), ncol =1)

for(j in 1:nrow(df.results))
	{
	if(df.results$indicator[j] == 1)
		{
		df.results$umse[j] = round(df.results$mse[j], digits = 4)
		}
	else
		{
		df.results$umse[j] = round((df.results$TrueParameterValues[j])^2, digits = 4)
		}
	}


#create dataframe for indicators - to include indicators across all repetitions
	df.indicators <- subset(df.results, select=c(indicator, regressors))
	names(df.indicators)[1] <- paste("indicator1")

#create dataframe for probability inclusion - to include indicators across all repetitions
	 df.inclprob <- subset(df.results, select=c(incprob1, regressors))
	 names(df.inclprob)[1] <- paste("incprob1")
	 

#create dataframe for UMSE - to include UMSE across all repetitions
	df.UMSE <- subset(df.results, select=c(regressors, umse))
	names(df.UMSE)[2] <- paste("UMSE1")

#create dataframe for CMSE - to include CMSE across all repetitions
	df.CMSE <- subset(df.results, select=c(regressors, cmse))
	names(df.CMSE)[2] <- paste("CMSE1")
	
	
	
	#beginning loop for cRepi (beginning at i=2)
	for (i in 2:cRep)
	{
	csvi=paste("repnum",i,".csv", sep = '')
	data_repi = read.csv(paste("repnum",i,".csv", sep = ''))
	delete = names(data_repi)%in% c("X","Constant")
	data_repi_a = data_repi[!delete]
	x = model.matrix(y~.,data_repi_a)[,-1]
	y=data_repi$y
	
		if(loclintrend)
		{
		ss <- AddLocalLinearTrend(state.specification=NULL, y)
		}
	
#running algorithm
	bsts.model <- bsts(y~x, state.specification = ss, niter = 100,ping=0, seed=1)
	summ<-SummarizeSpikeSlabCoefficients(bsts.model$coefficients)
	
#Column five is the inclusion probability across all niters
	repnumi.incprobi <- summ[,5]
#Column one is the mean coefficient estimate
	repnumi.meancoefi <- summ[,1]	

#create dataframe with inclusion probabilities and mean 			coefficient estimates
	df.resultsi <- data.frame(repnumi.incprobi, repnumi.meancoefi)
#create new column for indicators
	zerovector <- matrix(0, nrow = nrow(df.resultsi), ncol =1)
#add new indicator column to dataframe
	df.resultsi$indicatori <- zerovector

	#Set indicator variable	
	for (l in 1:nrow(df.resultsi$indicatori))
		if (df.resultsi$repnumi.incprobi[l] > prob)
		{
		df.resultsi$indicatori[l] <- 1
		}
	
	
#create column with row names corresponding to regressors - this seems backwards but the rownames are qualified as a variable so 	save them as a variable 
	df.resultsi$regressors <- rownames(df.resultsi)
	
#Delete Intercept row since is not in True Parameters dataframe
	df.resultsi <-df.resultsi[!(df.resultsi$regressors == 	"(Intercept)"),]
	
#merge results and true parameter dataframes. At this point we have a results df for this particular rep which includes the parameter estimates, indicator, true paramter
	df.resultsi <- merge(df.resultsi, truepar.df)
	
#create variable for MSE
	df.resultsi$msei <- round((df.resultsi$TrueParameterValues - df.resultsi$repnumi.meancoefi)^2, digits = 4)
	
#create variable for unconditional mean squared errors
	df.resultsi$cmsei <- matrix(0, nrow = nrow(df.resultsi), ncol =1)

	for(k in 1:nrow(df.results))
	{
		if(df.resultsi$indicatori[k] == 1)
		{
		df.resultsi$cmsei[k] = round(df.resultsi$msei[k], digits = 4)
		}
	}

#create variable for unconditional mean squared errors
	df.resultsi$umsei <- matrix(0, nrow = nrow(df.results), ncol =1)

	for(j in 1:nrow(df.results))
	{
		if(df.resultsi$indicatori[j] == 1)
		{
		df.resultsi$umsei[j] = round(df.resultsi$msei[j], digits = 4)
		}
		else
		{
		df.resultsi$umsei[j] = round((df.resultsi$TrueParameterValues[j])^2, digits = 4)
		}
	}


#create dataframe for indicators - to include indicators across all repetitions
	df.indicatorsi <- subset(df.resultsi, select=c(indicatori, regressors))
	df.indicators <- merge(df.indicators, df.indicatorsi)
	names(df.indicators)[1+i] <- paste("indicator",i, sep='')
	
#create dataframe for probability inclusion - to include indicators across all repetitions
	 df.inclprobi <- subset(df.resultsi, select=c(regressors, repnumi.incprobi))
	 df.inclprob <- merge(df.inclprob, df.inclprobi)
	 names(df.inclprob)[1+i] <- paste("incprob", i, sep='')
	 
#create dataframe for UMSE - to include UMSE across all repetitions
	df.UMSEi <- subset(df.resultsi, select=c(regressors, umsei))
	df.UMSE <- merge(df.UMSE, df.UMSEi)
	names(df.UMSE)[1+i] <- paste("UMSE", i, sep = '')
	
#create dataframe for UMSE - to include UMSE across all repetitions
	df.CMSEi <- subset(df.resultsi, select=c(regressors, cmsei))
	df.CMSE <- merge(df.CMSE, df.CMSEi)
	names(df.CMSE)[i+1] <- paste("CMSE", i, sep = '')

}
#End of cRep loop

#Calculate retention rate
	df.indicators$retentionrate <- rowMeans(df.indicators[,-1])

#Calculate Root mean square error
	df.UMSE$RUMSE <- round(sqrt(rowMeans(df.UMSE[,-1])), digits = 3)



#Calculate Root unconditional mean square error
	df.CMSE$RCMSE <- round(sqrt(rowSums(df.CMSE[,-1])/rowSums(df.CMSE[,-1] != 0)), digits=3)


	df.indicators <- merge(df.indicators, truepar.df)
	df.inclprob <- merge(df.inclprob, truepar.df)
	df.UMSE <- merge(df.UMSE, truepar.df)
	df.CMSE <- merge(df.CMSE, truepar.df)


	df.print1 <- subset(df.UMSE, select = c("regressors", "TrueParameterValues","RUMSE"))
	df.print2 <- subset(df.CMSE, select = c("regressors", "RCMSE"))
	df.print3 <- subset(df.indicators, select = c("regressors", "retentionrate"))

	df.printsumm <- merge(df.print1, df.print2)
	df.printsumm <- merge(df.printsumm, df.print3)
	df.printsumm <- rename(df.printsumm, c("TrueParameterValues"="TrueParVals", "RUMSE"="   RUMSE", "RCMSE"="  RCMSE", "retentionrate"="RetentionRate"))






	df.indicators$potencyind <- matrix(0, nrow = nrow(df.indicators), ncol =1)
	for(o in 1:nrow(df.indicators))
	{
		if (df.indicators$TrueParameterValues[o] != 0 )
		{
	df.indicators$potencyind[o] = 1
		}
	}

	df.indicators$gaugeind <- matrix(0, nrow = nrow(df.indicators), ncol =1)
	for(q in 1:nrow(df.indicators))
	{
		if (df.indicators$TrueParameterValues[q] == 0 )
		{
		df.indicators$gaugeind[q] <- 1	
		}
	}

	df.indicators$potencycalc <- matrix(0, nrow = nrow(df.indicators), ncol =1)
	for(m in 1:nrow(df.indicators))
	{
		if (df.indicators$TrueParameterValues[m] > 0 |df.indicators$TrueParameterValues[m] < 0 )
		{
		df.indicators$potencycalc[m] <- df.indicators$retentionrate[m]	
		}
	}
 
	df.indicators$gaugecalc <- matrix(0, nrow = nrow(df.indicators), ncol =1)

	for(n in 1:nrow(df.indicators))
	{
		if (df.indicators$TrueParameterValues[n] == 0 )
		{
		df.indicators$gaugecalc[n] <- df.indicators$retentionrate[n]	
		}
	}
 
 #Delete lagged y observation for calculations
	 df.ind <- df.indicators[!df.indicators$regressors == "xLy",]
 
 #Select only those observations for gauge calc
 	df.gaugeind <- df.ind[df.ind$gaugeind == 1,]
 	df.gaugeind <- subset(df.gaugeind, select = c(regressors, gaugecalc))
 
 #Select only those observations for potency calc
 	df.potencyind <- df.ind[df.ind$potencyind == 1,]
 	df.potencyind <- subset(df.potencyind, select = c(regressors, potencycalc))
 
 
 	print(df.printsumm)
 	print("potency is")
 	print(mean(df.potencyind$potencycalc))
 
 	print("gauge is")
 	print(mean(df.gaugeind$gaugecalc))
 
	print("#####################################################")
 
}
#end of case loop
 #sink()
 

